# Reading ".NET IL Assembler"

## ilのコンパイル方法

    > call "%vs120comntools%vsvars32.bat"
    > ilasm.exe myasm.il

## 1章

* `.assembly extern` はアセンブリ参照を定義するもの。
  * 続くアセンブリ名にはファイル名を指定しない。
    * `mscorlib.dll` と指定してしまうと `mscorlib.dll.dll` だとか `mscorlib.dll.exe` が検索されてしまうので
      見つからずランタイムエラーになる。
  * `{ auto }` とするとバージョンを自動検出する。
    * ただし `1.0` と `1.1` には自動検出機能がないので注意。
* `.assembly <name>` で`Assembly`という名前のメタデータを定義。
* `.module <name>` で`Module`という名前のメタデータを定義。
* 値型と列挙型には疑似フラグ `value` と `enum` を指定出来る。
  * ただし `extends` が指定された場合はこれらのフラグは無視される。
* `TypeDef` ブロックは一度クローズしても、別の場所でオープンしなおすことが可能。
  * `amendment` (改正、修正)と呼ばれるテクニック。
  * `TypeDef` の改正時に指定されたフラグや`extends` `implement` 句は無視される。
    つまりこれらは最初の`TypeDef`定義時に指定すべき。
* アクセス修飾子
  * `public`は任意の場所にあるアセンブリからアクセス可能。
  * `assembly`は同じアセンブリ内からのみアクセス可能。
  * `family`はすべての子クラスからアクセス可能。
  * `famandassem`は同じアセンブリ内にあり、かつ子クラスからのみアクセス可能。
  * `famorassem`は同じアセンブリ内か、子クラスからのみアクセス可能。
  * `private`はクラス内からのみアクセス可能。
  * `privatescope`は同じモジュール内の任意の場所からアクセス可能。
    このフラグがデフォルト。
    `privatescope`は親/名前/シグネチャの3組によって識別される。
    つまり同じクラス、同じ名前、同じ型のプライベート項目を複数作成出来てしまうため非推奨。
* メソッド
  * インストラクション(命令：ILコードにコンパイルされる)
  * インストラクションをマーキングするラベル
  * ディレクティブ(メタデータ、ヘッダ設定、マネージ例外処理句などにコンパイルされる)
* `.locals`によって宣言されるローカル変数には必ず`init`を指定する
  * 変数がゼロ初期化される
  * 指定しない場合はエラー
    * 実行時に検証が失敗する
    * 検証が無効化されている場合は完全信頼モードでしか動作させられない
* ラベル
  * ラベルに続く***最初の命令***がマークされる
  * 個別の行に分ける必要は無し
* ILは厳密な***スタックベース***の言語
* ilasm 1.0/1.1 では前方方向しか参照できないので場合によって前方宣言する必要がある

## 2章

* ILにはローカル変数を読み取り/保存するための命令が4つまであらかじめ定義されている
  * `ldloc.0` .. `ldloc.3`, `stloc.0` .. `stloc.3`
* 標準形式の命令には4バイトの引数が続く
* 短縮形式の命令(`br.s` `brfalse.s` `brtrue.s`)には1バイトの引数が続く
  * つまり前方128バイト、後方127バイトまで
  * すべての命令に短縮形式があるので、255バイトの範囲を超えない限りは
    4つ以上の変数を渡しても大丈夫
* ILコンパイラによっては標準/短縮どちらの命令にすべきかを自動判断するものがあるが、
  .NET標準では書かれたとおりにしかコードが生成されない
* ilasmはildasmが生成したコードをコンパイルできないことがある
  * コードの最適化によってILコードが失われる場合があることが原因
* `ldc.i4.n` の `n` には `0` から `8` まで指定可能
  * `-1` をロードする場合は `ldc.i4.m1`
* `ldc.i4` の短縮形式 `ldc.i4.s` は同じく(`-128`から`127`までの)バイト値の範囲で機能する
* `try`ブロックはスタックが空の状態でなければ開始できない

## 3章

* ILの便利機能
  * エイリアス
  * コンパイル制御ディレクティブ
  * 現在のクラスおよび親を表す特別なキーワード
* エイリアス
  * `.typedef` キーワードで定義
  * クラス、メソッド、フィールド、カスタム属性に指定可能
  * メソッドのエイリアスを定義する場合、完全修飾名とシグネチャを指定する
    * `.typedef method`で始める
  * フィールドの場合も同じ
    * `.typedef field`で始める
  * カスタム属性のエイリアスについては16章まで保留
  * エイリアス名はモジュールの範囲で有効
    * 同一モジュール内での再定義は不可
  * エイリアスは字句的に使用される前の位置で定義する必要がある
  * モジュール内で一意であるべき
    * 別の2つの項目を同じエイリアスにすることはできない
    * 1つの項目に対して複数のエイリアスを定義することは可能
  * エイリアスはコンパイル後のアセンブリ内でも残る
    * `ildasm Simple3.exe`
    * `MANIFEST`内
* コンパイル制御ディレクティブ
  * `#include "<file name>"`
  * `#define <symbol name>`
  * `#define <symbol name> "Some text"`
  * `#undef`
  * `#ifdef`
  * `#ifndef`
  * `#else`
  * `#endif`
* 現在のクラスから相対的なオブジェクトを表すキーワード
  * `.this`
  * `.base`
  * `.nester`
    * ネストされたクラス内でのみ使用可能
    * ネスト元のクラスを表す(はず)

## 4章

* Microsoft Windows Portable Executable and Common Object File Format (PE/COFF)
* マネージ実行ファイルの構造
  * MS DOS ヘッダ (64 Bytes)
  * MS DOS スタブ (64 Bytes)
  * PE シグネチャ (4 Bytes)
  * COFF ヘッダ (20 Bytes)
  * PE ヘッダ (224 Bytes)
    * Data Directory Table
  * セクションヘッダ
* MS DOS ヘッダ/スタブ/PE シグネチャ
  * イメージファイルにのみ存在
  * 0x3Cの位置にPEシグネチャへのファイルポインタが格納されている
  * PEシグネチャはMS DOSスタブに続く4バイト
    * 必ずしも直後ではない
    * `P` `E` `null` `null`
* COFF ヘッダ
  * PEシグネチャの直後に格納されている
  * PE/COFFファイルの最も汎用的な性質が記述されている
  * COFFヘッダの定義は `Winnt.h`
  * `Characteristics` フィールド
    * 実行ファイルは `0x010E` (IMAGE_FILE_EXECUTABLE_IMAGE |
      IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED |
      IMAGE_FILE_32BIT_MACHINE)
    * DLLファイルは `0x210E` (IMAGE_FILE_EXECUTABLE_IMAGE |
      IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED |
      IMAGE_FILE_32BIT_MACHINE | IMAGE_FILE_DLL)
    * 64ビットバイナリの場合には `IMAGE_FILE_32BIT_MACHINE` が無いかも
    * CLR 4.0以降では 実行ファイルは `0x0022` DLLファイルは `0x2022`
* PE ヘッダ
  * `オプションヘッダ` ではあるが、オブジェクトファイルには含まれないというだけ
  * PEヘッダのサイズは不定
    * `SizeOfOptionalHeader` フィールドで指定
  * PEヘッダの定義は `Winnt.h`
* Data Directory Table
  * 32ビットの場合はオフセット96、64ビットの場合はオフセット112から開始
  * 0: エクスポートディレクトリテーブルアドレスおよびサイズ
  * 1: インポートテーブルアドレスおよびサイズ
  * 2: リソーステーブルアドレスおよびサイズ
  * 3: 例外テーブルアドレスおよびサイズ
  * 4: 認証テーブルアドレスおよびサイズ
  * 5: ベースリロケーションテーブルおよびサイズ
  * 6: デバッグデータアドレスおよびサイズ
  * 7: アーキテクチャデータアドレスおよびサイズ
  * 8: グローバルポインタ
  * 9: TLS(Thread Local Storage)テーブルアドレスおよびサイズ
  * 10: ロード設定テーブルアドレスおよびサイズ
  * 11: 境界インポートテーブルアドレスおよびサイズ
  * 12: インポートアドレステーブルアドレスおよびサイズ
  * 13: 遅延インポートデスクリプタアドレスおよびサイズ
  * 14: 共通言語ランタイムヘッダアドレスおよびサイズ
  * 15: 予約済み
* セクションヘッダ
  * 定義される位置は必ずPEヘッダの直後
  * COFFヘッダのNumberOfSectionsフィールドに個数が定義されている
  * 40バイトの構造体
  * `IMAGE_SECTION_HEADER` の `VirtualAddress` は実際にはセクションの始点のRVA
  * セクション名はイメージファイルではASCIIで8文字の制限があるが、オブジェクトファイルの場合はそれよりも長い名前にできる
* CLRヘッダ
  * .NET Framework SDKの`CorHdr.h`で定義されている

## 5章

