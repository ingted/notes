# 非モノイドへの対応(翻訳)
難しくないモノイド パート3

原文： [Working with non-monoids][link01]

----

シリーズの [前回の記事][link02] ( [原文][link03] )ではきちんとしたモノイドだけを扱いました。
しかし対象となるものがモノイド **ではない** 場合はどうでしょう？
どうすればいいですか？

そこで今回はほぼありとあらゆるものをモノイドへと変換するようなテクニックを紹介します。

その際に、シングルトンよりもリストを使用したほうがいいだとか、
できるだけオプション型を使用したほうがいいだとかいうような、
一般的かつ重要な関数型のデザインイディオムについても多数紹介します。

## クロージャにする

きちんとしたモノイドについて再確認すると、
モノイドとはクロージャ、結合性、単位元という
3つの要素を持つものでした。
それぞれの条件毎に課題があるため、順を追って説明していきます。

まずはクロージャです。

場合によっては、値同士を足しあわせたいけれども、
連結後の値が元の値とは異なる型になることがあります。
この場合はどのように処理したらよいでしょうか？

1つの方法としては、クロージャになるような新しい型と
元の型とのマッピングを用意します。
このアプローチは前回 ``Customer`` と ``CustomerStats`` の例で紹介した通りです。
元の型に手を加える必要がないため、多くの場合はこの方法が最も簡単です。

一方、どうしても ``map`` を使用したくなく、
その代わりにクロージャの条件に見合うような新しい型を
作りたい場合もあるでしょう。

いずれにしても新しい型を作るか、既存の型を手直しするかしなければいけないので、
クロージャにするためにはそれぞれ同じような方法が使えます。

### 新しい複合型を作成するためにクロージャ型を組み合わせる

ご存じの通り、数値型は足し算やかけ算のような基本的な演算に対しては
クロージャの条件を満たしています。
また、非数値型であっても、文字列やリストであれば連結に対して
クロージャになっています。

このことから分かるのは、これらの型を組み合わせた型も
やはりクロージャであるということです。
これらの型の「add」を使えば、まさに複合型の「add」を定義できるというわけです。

たとえば以下の通りです：

```fsharp
type MyType = { count:int; items:int list }

let addMyType t1 t2 =
    { count = t1.count + t2.count
      items = t1.items @ it2.items }
```

``addMyType`` 関数は ``int`` フィールドに対しては整数の足し算、
``list`` フィールドについてはリストの連結を行っています。
そうすると ``MyType`` は ``addMyType`` に対してクロージャになります。
実際、クロージャというだけでなく、モノイドでもあります。
つまり今回の場合はこれで完了です！

これはまさに [前回の記事][link04] ( [拙訳][link05] )で ``CustomStats`` に対して
採用したアプローチそのものです。

つまり1つめのヒントです：

* デザインのヒント：モノイド的な型を簡単に作成したければ、
  型の各フィールドもモノイドにします

そこで問題です：
このようにした場合、新しい複合型の「ゼロ」は何になるのでしょう？

### 非数値型に対処する

上のアプローチは複合型を作る場合には有効です。
しかし明らかに数値的な同値性を持たないような非数値型についてはどうでしょうか？

単純な場合を考えてみましょう。
以下のようにchar同士を足しあわせたいとします：

```fsharp
'a' + 'b' -> 何？
```

しかしchar足すcharは別の文字にはなりません。
それぞれが空でなければstringになります。

```fsharp
'a' + 'b' -> "ab" // クロージャにならない！
```

しかしやっかいなことに、この挙動はクロージャの条件を満たしません。
この問題を修正する1つの方法としては、charをstringに強制的に変換して
クロージャになるようにしてしまうことです：

```fsharp
"a" + "b" -> "ab"
```

しかしこの方法はcharにしか通用しません。
その他の型にも通用するような汎用的な解決策はないのでしょうか？

そこで、少し時間を取って ``string`` と ``char`` との
関係について考えてみてください。
stringはcharのリストあるいは配列だと考えられます。

別の言い方をすれば、以下のようにcharのリストにすればよいというわけです：

```fsharp
['a'] @ ['b'] -> ['a'; 'b'] // リストが正解！
```

こうすればクロージャの条件も満たします。

さらに、実を言うとこの方法は **ほとんどの** 問題に対する解決策になっています。
というのも、リストは **あらゆるもの** を含むことができ、
また(連結に対しては)常にモノイドだからです。

そこで2つめのヒントです：

* デザインのヒント：非数値型をクロージャにする場合、単一の項目をリストで置き換えること。

場合によってはモノイドにするためにリストを用意した後、
処理が終わった時点で別の型へと変換し直す必要があるかもしれません。

たとえば ``char`` の場合、すべての処理はcharのリストに対して行い、
最後にだけstringへと変換すればよいでしょう。

というわけで、「モノイドchar」モジュールを作ってみましょう。

```fsharp
module MonoidChar =
    open System

    /// "モノイド的char"
    type MChar = MChar of Char list

    /// 1つのcharを"モノイド的char"へと変換する
    let toMChar ch = MChar [ch]

    /// 2つのモノイド的charを足す
    let addChar (MChar l1) (MChar l2) =
        MChar (l1 @ l2)

    /// 中置バージョン
    let (++) = addChar

    /// 文字列へと変換する
    let toString (MChar cs) =
        new String(List.toArray cs)
```

この通り、 ``MChar`` は1つのcharではなく、
charのリストに対するラッパーになっています。

ではテストしてみます：

```fsharp
open MonoidalChar

// 2つのcharを足しあわせてstringに変換する
let a = 'a' |> toMChar
let b = 'b' |> toMChar
let c = a ++ b
c |> toString |> printfn "a + b = %s"
// 結果："a + b = ab"
```

もう少し手を加えるとすれば、以下のようにして
一連のcharに対してmap/reduceを使ってみてもよいでしょう：

```fsharp
[' '..'z']
|> List.filter System.Char.IsPunctuation
|> List.map toMChar
|> List.reduce addChar
|> toString
|> printfn "区切り文字は%s"
// 結果：区切り文字は!"#%&'()*,-./:;?@[\]_
```

### エラーに対するモノイド

``MonoidalChar`` の例ではとても単純で、
おそらくは別の方法を使っても実装することができるでしょう。
しかしこのテクニックは一般に通用するような非常に便利なものです。

たとえばいくつかのバリデーションを行うようなシンプルなモジュールがあるとします。
``Success`` と ``Failure`` という2つのオプションがあり、
``Failure`` にはエラー文字列が関連づけられています。

```fsharp
module Validation =

    type ValidationResult =
        | Success
        | Failure of string

    let validateBadWord badWord (name:string) =
        if name.Contains(badWord) then
            Failure ("文字列に不正な単語が含まれています：" + badWord)
        else
            Success

    let validateLength maxLength name =
        if String.length name > maxLength then
            Failure "文字列が長すぎます"
        else
            Success
```

実際には1つの文字列に対して複数のバリデーションを行い、
最終的には何らかの方法で足しあわされたすべての結果を取得することになるでしょう。

これはまさにモノイドの出番です！
2つの結果の対を足しあわせることができれば、
後はもう任意個の結果を足しあわせられるわけです！

しかし問題があります。
どうやって **2つ** のバリデーション結果を連結すればよいでしょうか？

```fsharp
let result1 = Failure "文字列がnullまたは空です"
let result2 = Failure "文字列が長すぎます"

result1 + result2 = ????
```

愚直なアプローチとしては文字列同士を連結する方法ですが、
ところがこれだとフォーマット文字列を使っていたり、
ローカライゼーション用にリソースIDを使ったりした場合にうまくいきません。

そうではなくて、``Failure`` ケースを単一の文字列ではなく
文字列の **リスト** へと変換すればよいです。
こうすれば連結後の結果も単純になります。

実際のコードは以下のようになります。
リストを使うように ``Failure`` を変更してあります：

```fsharp
module MonoidalValidation =

    type ValidationResult =
        | Success
        | Failure of string list

    // 1つの文字列をFailureケースに変換するためのヘルパ
    let fail str = 
        Failure [str]

    let validateBadWord badWord (name:string) =
        if name.Contains(badWord) then
            fail ("文字列に不正な単語が含まれています：" + badWord)
        else
            Success

    let validateLength maxLength name =
        if String.length name > maxLength then
            fail "文字列が長すぎます"
        else
            Success
```

このコードではそれぞれのバリデーション中で
文字列を指定した ``fail`` を呼び出していますが、
実際にやっていることは文字列のリストとしているだけです。
このようにしておくことによって、バリデーションの結果を
それぞれ連結できるようになるというわけです。

ここまで来れば ``add`` 関数が作成できます。

ロジックは以下の通りです：

* 2つとも ``Success`` の場合、連結後の結果は ``Success``
* 1つが ``Failure`` の場合、連結後の結果は ``Failure``
* 2つとも ``Failure`` の場合、連結後の結果は2つを連結したリストの ``Failure``

コードは以下の通りです：

```fsharp
module MonoidicValidation =

    // 上の通り

    /// 2つの結果を足しあわせる
    let add r1 r2 =
        match r1,r2 with
        | Success,    Success -> Success
        | Failure f1, Success -> Failure f1
        | Success,    Failure f2 -> Failure f2
        | Failure f1, Failure f2 -> Failure (f1 @ f2)
```

ロジックをチェックするテストもいくつか用意しましょう：

```fsharp
open MonoidalValidation

let test1 =
    let result1 = Success
    let result2 = Success
    add result1 result2
    |> printfn "結果は %A"
    // "結果は Success"

let test2 =
    let result1 = Success
    let result2 = fail "文字列が長すぎます"
    add result1 result2
    |> printfn "結果は %A"
    // 結果は Failure ["文字列が長すぎます"]

let test3 =
    let result1 = fail "文字列がnullまたは空です"
    let result2 = fail "文字列が長すぎます"
    add result1 result2
    |> printfn "結果は %A"

    // 結果は Failure
    //   [ "文字列がnullまたは空です";
    //     "文字列が長すぎます" ]
```

もう少し現実的な例として、適用したいバリデーション関数を
リストとして用意してみます：

```fsharp
let test4 =
    let validationResults str =
        [
        validateLength 10
        validateBadWord "monad"
        validateBadWord "cobol"
        ]
        |> List.map (fun validate -> validate str)

    "cobol では monad がネイティブでサポートされています"
    |> validationResults
    |> List.reduce add
    |> printfn "結果は %A"
```

実行結果は3つのエラーメッセージを含んだ ``Failure`` になります：

```
結果は Failure
  ["文字列が長すぎます"; "文字列に不正な単語が含まれています：monad";
   "文字列に不正な単語が含まれています：cobol"]
```

このモノイドの説明を終わらせる前にもう1つ確認しておくべき事があります。
「ゼロ」が必要です。
どんな値になるでしょうか？

定義によると、別の結果と連結すると別の結果をそのまま返すような値になります。

この定義から、「ゼロ」が ``Success`` であると見抜いていただけたでしょうか。

```fsharp
module MonoidalValidation =

    // 上の通り

    // 単位元
    let zero = Success
```

おわかりの通り、reduceの対象が空のリストになっている場合にこのゼロが必要になります。
そこで以下のように、空の ``ValidationResult`` のリストを指定することで、
適用するバリデーション関数が全く無い場合をテストしてみることにします。

```fsharp
let test5 =
    let validationResults str =
        []
        |> List.map (fun validate -> validate str)

    "cobol では monad がネイティブでサポートされています"
    |> validationResults
    |> List.fold add zero
    |> printfn "結果は %A"

    // 結果は Success
```

なおこのコードではランタイムエラーが発生しないよう、
``reduce`` を ``fold`` に書き換えている点に注意してください。

### Listのパフォーマンス

リストを使用することの利点はもう1つあります。
他の連結方法と比較すると、
リストの連結は参照先のオブジェクトを変更したり再配置したりする必要がないため、
計算とメモリ使用率の双方において比較的コストが低く済みます。

たとえば前回の記事では文字列をラップした ``Text`` ブロックを定義して、
これらのコンテンツを文字列として連結していました。

```fsharp
type Text = Text of string

let addText (Text s1) (Text s2) =
    Text (s1 + s2)
```

しかし文字列が大きくなると、このような連続的な結合のコストが高くなります。

たとえば ``Text`` ブロックが代わりに文字列の **リスト** であるような
別の実装を検討してみましょう。

```fsharp
type Text = Text of string list

let addText (Text s1) (Text s2) =
    Text (s1 @ s2)
```

実装としてはほとんど変わりませんが、パフォーマンスは劇的に改善されています。

すべての操作を文字列の **リスト** として処理しておき、
処理工程の最後の最後に通常の文字列へと戻せばよいでしょう。

また、リストでは思うようなパフォーマンスが出せないと思うのであれば、
このアプローチを拡張してツリーやヒープのような古典的データ構造を使うようにしたり、
ResizeArrayのような可変型を使うようにしたりすることも簡単に可能です。
(パフォーマンスについては今回の記事の末尾にある付録でもう少し詳細な説明をしています。)

### 専門用語注意

オブジェクトのリストをモノイドとして使用するというコンセプトは
数学的に一般的なもので、 [「フリーモノイド」][link06] (free monoid)と呼ばれています。
また、コンピュータサイエンスの分野では ``A*`` と書いて
 [「クリーネスター」][link07] (Kleene star)とも呼ばれています。
また、空のリストを許容しない場合には要素がないという状態がありません。
このような亜種は「自由半群」 (free semigroup)あるいは ``A+`` と書いて
「クリーネプラス」 (Kleene plus)と呼ばれます。

「スター」や「プラス」という記法については正規表現の経験があれば
お馴染みのものでしょう。 [*](#note01)

<a name="note01">*</a>
正規表現とモノイドとの間に関連があるなどとはきっと思いもよらなかったことでしょう！
実のところ、両者には [さらに深い関係][link08] があります。

## 結合性

クロージャの説明が終わったので、次は結合性です。

連載記事のかなり最初の方に引き算や割り算など、結合性の無い演算子が出てきました。

つまり ``5 - (3 - 2)`` と ``(5 - 3) - 2`` とは同じ値ではありません。
したがって引き算には結合性がないことがわかります。
また、 ``12 / (3 / 2)`` と ``(12 / 3) / 2`` も異なるため、割り算にも結合性がありません。

これらに対する正しい1つの答えはありません。
というのも、左から右にかけて計算するのか、右から左にかけて計算するのかによって
答えが異なるという問題をきちんと検討しなければいけないからです。

事実、F#の標準ライブラリにはどちらでも好きな方を選択できるように
2つのバージョンの ``fold`` と ``reduce`` が用意されています。
一般的な ``fold`` や ``reduce`` は左から右に処理が進みます：

```fsharp
// (12 - 3) - 2 と同じ
[12;3;2] |> List.reduce (-) // => 7

// ((12 - 3) - 2) - 1 と同じ
[12;3;2;1] |> List.reduce (-) // => 6
```

しかし ``foldBack`` や ``reduceBack`` の場合は右から左に処理が進みます：

```fsharp
// 12 - (3 - 2) と同じ
[12;3;2] |> List.reduceBack (-) // => 11

// 12 - (3 - (2 - 1)) と同じ
[12;3;2;1] |> List.reduceBack (-) // => 10
```

したがって、結合性の条件を満たすと言うことはつまり
``fold`` と ``foldBack`` のどちらを使っても
**同じ** 結果が必ず得られるということだと言えます。

### 演算子を要素に組み込む

しかし一貫性のあるモノイド的アプローチ **こそ** が必要なのだとすると、
多くのケースで通用するようなアプローチとしては
それぞれの要素の性質として演算子を組み込んでしまうとよいでしょう。
演算子を動詞ではなく名詞にしてしまうのです。

たとえば ``3 - 2`` は ``3 + (-2)`` ともみなせます。
「引く」という動詞ではなく、「マイナス2」という名詞とするわけです。

今回の場合、上の例は ``5 + (-3) + (-2)`` となります。
すると演算子が足し算になり、足し算には **確かに** 結合性があるので、
``5 + (-3 + -2)`` は ``(5 + -3) + -2`` と同じ結果になります。

同じ事が割り算にも当てはまります。
``12 / 3 / 2`` は ``12 * (1/3) * (1/2)`` と変換でき、
演算子をかけ算とすることができます。
したがって結合性を持つようになりました。

この演算子を要素の性質として組み込んでしまうというアプローチは
うまい具合に一般化できます。

つまり次のようなヒントです：

* デザインのヒント：ある演算子に対する結合性が必要になる場合、
  演算子をオブジェクトへと組み込んでみること

具体的な動作を確認するために、以前の例を再度利用してみます。
皆さんが覚えているかわかりませんが、最初の記事では文字列に対して
結合性を持たない例として ``subtractChars`` を検討しました。

``subtractChars`` を単純に実装すると以下のようになります：

```fsharp
let subtractChars (s1:string) (s2:string) =
    let isIncluded (ch:char) = s2.IndexOf(ch) = -1
    let chars = s1.ToCharArray() |> Array.filter isIncluded
    System.String(chars)

// 中置バージョン
let (--) = subtractChars
```

この実装を使っていくつかテストしてみます：

```fsharp
"abcdef" -- "abd"   // "cef"
"abcdef" -- ""      // "abcdef"
```

また、結合性の条件を満たしていないことも確認できます：

```fsharp
("abc" -- "abc") -- "abc"   // ""
"abc" -- ("abc" -- "abc")   // "abc"
```

どうすれば結合性を持てるようにできるでしょうか？

ヒントは先ほど数値に対して行ったように、「引き算性」を
演算子からオブジェクトへと組み込むことでした。

つまり以下のように、削除したい文字列をキャプチャしているような
「引き算」あるいは「文字削除」データ構造として文字列を置き換えればよいわけです：

```fsharp
let removalAction = (subtract "abd") // データ構造
```

そしてこのデータ構造を文字列に対して「適用」します：

```fsharp
let removalAction = (subtract "abd")
removalAction |> applyTo "abcdef" // 結果は "cef"
```

このアプローチを使用すると、先ほどは結合性を持たなかった例であっても
以下のようにして結合性を持たせることができるようになります：

```fsharp
let removalAction = (subtract "abc") + (subtract "abc") + (subtract "abc")
removalAction |> applyTo "abc"  // 結果は ""
```

確かにこのコードはオリジナルのコードとは厳密に同じではありませんが、
こちらの方が実際には多くの場合に適合することがわかるでしょう。

実装は以下の通りです。
``CharsToRemove`` には文字セットが含まれるように定義してあり、
その他の関数についてもそれに応じた自然なものになっています。

```fsharp
/// 削除する文字のリストを保持する
type CharsToRemove = CharsToRemove of Set<char>

/// 新しいCharsToRemoveのインスタンスを生成する
let subtract (s:string) =
    s.ToCharArray() |> Set.ofArray |> CharsToRemove

/// CharsToRemoveを文字列に適用する
let applyTo (s:string) (CharsToRemove chs) =
    let isIncluded ch = Set.exists ((=) ch) chs |> not
    let chars = s.ToCharArray() |> Array.filter isIncluded
    System.String(chars)

/// 2つのCharsToRemoveを連結して新しいものを返す
let (++) (CharsToRemove c1) (CharsToRemove c2) =
    CharsToRemove (Set.union c1 c2)
```

テストしてみましょう！

```fsharp
let test1 =
    let removalAction = (subtract "abd")
    removalAction |> applyTo "abcdef" |> printfn "結果は%s"
    // 「結果はcef」

let test2 =
    let removalAction = (subtract "abc") ++ (subtract "abc")
    removalAction |> applyTo "abc" |> printfn "結果は%s"
    // 「結果は」
```

このアプローチはある意味で、 **データ** ではなく
**アクション** をモデル化しているものだと考えるとよいでしょう。
``CharsToRemove`` アクションのリストがあり、これらを1つの「巨大な」
``CharsToRemove`` アクションとして連結し、
最終的にはこの1つのアクションを実行することで
途中の計算が完了しています。

もう1つ別の例を紹介しますが、この時点で
「これはどうやら関数っぽいものじゃないだろうか？」と思うかもしれません。
果たしてその答えは「その通り！」なのです。

実際、 ``CharsToRemove`` というデータ構造を作成するよりも、
以下のようにして元々の ``subtractChars`` に対して部分適用することができます：

(なお簡単に部分適用できるようにするためパラメータの順序を入れ替えています)

```fsharp
// 部分適用のためにパラメータを逆順にする
let subtract str charsToSubtract =
    subtractChars charsToSubtract str

let removalAction = subtract "abd"
"abcdef" |> removalAction |> printfn "結果は%s"
// 「結果はcef」
```

また、特別な ``applyTo`` 関数も不要です。

しかし引き算用の関数が複数ある場合にはどうすればいいでしょうか？
それぞれの部分適用関数は ``string -> string`` というシグネチャを持ちますが、
どうやってそれぞれを「足し算」したらよいのでしょう？

```fsharp
(subtract "abc") + (subtract "abc") + (subtract "abc") = ?
```

答えはもちろん関数合成です！

```fsharp
let removalAction2 = (subtract "abc") >> (subtract "abc") >> (subtract "abc")
removalAction2 "abcdef" |> printfn "結果は%s"
// 「結果はdef」
```

これは ``CharsToRemove`` のデータ構造を作成した場合と機能的に同じです。

「アクションとしてのデータ構造」と関数によるアプローチは厳密には同じではありません。
たとえば ``CharsToRemove`` はsetを使用していて、
最終的には文字列にしか適用できないのでこちらの方が効率的だと言えます。
しかしいずれにおいても最終的には同じ結果が得られます。
どちらが適切なのかは対象となる問題によって異なります。

関数とモノイドの関係については次回の記事でもう少し説明する予定です。

## 単位元

では最後の条件である単位元を見ていきます。

これまでにも説明した通り、単位元は必須の条件ではありませんが
空のリストを扱うことがある場合には有った方が便利です。

数値型の値の場合、演算子に対する単位元は比較的簡単に見つけられます。
(足し算の場合は) ``0``、(かけ算の場合は) ``1``、
(maxの場合は) ``Int32.MinValue`` のいずれかであることがほとんどです。

また、数値型しか含まないような構造体の場合にも同じことがいえます。
構造体のすべてのメンバに対して、適切な単位元を設定すればよいのです。
これはまさに前回の記事にあった ``CustomerStats`` 型がよい例です。

しかし数値型ではないものを含むオブジェクトの場合はどうすればよいでしょうか？
候補として適切そうなものがない場合に「ゼロ」あるいは単位元を
どうやって作成すればよいでしょう？

正解は「でっち上げる」です。

大まじめですよ！

具体的な例は前回の記事にあったもので、
``OrderLine`` 型における ``EmptyOrder``が該当します：

```fsharp
type OrderLine \
    | Product of ProductLine
    | Total of TotalLine
    | EmptyOrder
```

もう少し詳しく説明しましょう。
手順としては2つありました：

* まず、新しいケースを作成して、それを(上のように) ``OrderLine`` の代用品として追加
* 次に、(以下のように) ``addLine`` 関数がこのケースを処理するように変更

```fsharp
let addLine orderLine1 orderLine2 =
    match orderLine1, orderLine2 with
    // どちらかがゼロ？その場合は他方を返す
    | EmptyOrder, _ -> orderLine2
    | _, EmptyOrder -> orderLine1
    // その他のロジック...
```

これだけです。

新しく拡張した型は古い注文品目のケースとも整合性がある上、
**さらに** 新しいケースにも対応します。
したがって古いケースに対する挙動の大部分が再利用できます。

特に、新しく拡張した型はすべてのモノイド規則を満たしていることがわかるでしょうか？

* 新しい型の値の対は足しあわせると別の新しい値が得られる(クロージャ)
* 旧い型において連結の順序が不同であれば新しい型でも順不同(結合性)
* そして最後に...追加したケースが新しい型の単位元になる

### PositiveNumberをモノイドに変換する

これまでに紹介した半群に対しても同じ事ができます。

たとえば厳密に正の整数には(足し算に対して)単位元がありません。
したがってこれは半群です。
そこで「特別なケースを追加する」テクニックを使って
(単なる ``0`` ではない！)ゼロを作成したい場合には、
特別な(整数ではない) ``Zero`` ケースを追加して、
このケースを処理するように ``addPositive`` 関数を以下のように修正します：

```fsharp
type PositiveNumberOrIdentity =
    | Positive of int
    | Zero

let addPositive i1 i2 =
    match i1, i2 with
    | Zero, _ -> i2
    | _, Zero -> i1
    | Positive p1, Positive p2 -> Positive (p1 + p2)
```

確かに ``PositiveNumberOrIdenitty`` の例は恣意的ではありますが、
「普通」の値と特別なゼロ値が別個に必要な場合には同じアプローチが
利用できるということがわかると思います。

### 一般的な解決策

この方法にはいくつか欠点があります：

* 通常ケースとゼロケースの **2つ** のケースを処理しなければならない
* 独自の型と独自の足し算用関数を用意しなければならない

残念ながら1番目の問題については対処しようがありません。
自然なゼロの無いシステムにおいて、ゼロを人為的に作成した場合には
常に2つのケースを処理することになります。

しかし2番目の問題についてはある程度の対策があります！
新しい独自の型を毎回作成するのではなく、
2つのケースを持った **ジェネリック** 型を作成すればよいのです。
つまり以下のように、1つは普通の値に対するケース、
もう1つは人為的に作成したゼロに対するケースにします：

```fsharp
type NormalOrIdentity<'T> =
    | Normal of 'T
    | Zero
```

このような型を見たことがありませんか？
これはまさにOption型そのものです！

つまり通常の値セットからは外れるような単位元が必要であれば、
``Option.None`` を使ってそれを表すことができます。
そして、その他すべての通常の値に対しては ``Option.Some`` を使います。

``Option`` 型を使うことのもう1つの利点は、
同じく完全にジェネリックな「足し算」関数を作成できるということです。
まずは以下のようにしてみます：

```fsharp
let optionAdd o1 o2 =
    match o1, o2 with
    | None, _ -> o2
    | _, None -> o1
    | Some s1, Some s2 -> Some (s1 + s2)
```

ロジックは単純です。
オプションのいずれかが ``None`` であれば他方のオプションを返します。
両方が ``Some`` の場合はそれぞれラップされた値を解除してから足しあわせ、
その後再び ``Some`` にラップします。

しかし最後の行にある ``+`` によって足しあわせる型が仮定されてしまいます。
そこで以下のように足し算用の関数を明示的に指定できるようにするとよいでしょう：

```fsharp
let optionAdd f o1 o2 =
    match o1, o2 with
    | None, _ -> o2
    | _, None -> o1
    | Some s1, Some s2 -> Some (f s1 s2)
```

実際には足し算用の関数を部分適用したものを使うことになるでしょう。

さて以上でもう1つ重要なヒントが得られました：

* デザインのヒント：演算子に対する単位元を用意する場合、
  判別共用体に特別なケースを追加する、あるいはもっと単純にはOption型を使用する

### PositiveNumber再考

そこで再び正の整数の例を ``Option`` 型で実装してみましょう。

```fsharp
type PositiveNumberOrIdentity = int option
let addPositive = optionAdd (+)
```

かなりシンプルになりました！



[link01]: http://fsharpforfunandprofit.com/posts/monoids-part3/ "Working with non-monoids"
[link02]: 00.The%20'Understanding%20monoids'%20series.md "「モノイドを理解する」シリーズ"
[link03]: http://fsharpforfunandprofit.com/series/understanding-monoids.html "The 'Understanding monoids' series"
[link04]: http://fsharpforfunandprofit.com/posts/monoids-part2/ "Monoids in practice"
[link05]: 02.Monoids%20in%20practice.md "実践モノイド"
[link06]: http://en.wikipedia.org/wiki/Free_monoid "Free monoid"
[link07]: http://en.wikipedia.org/wiki/Kleene_star "Kleene star"
[link08]: http://scienceblogs.com/goodmath/2008/03/06/monoids-and-computation-syntac/ "Monoids and Computation: Syntactic Monoids"
