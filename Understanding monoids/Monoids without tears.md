# 難しくないモノイド
数学的な知識をほぼ必要とせずに一般的な関数パターンを説明する

原文：[Monoids without tears][link01]

----

もしも読者にOOのバックグラウンドがあるのであれば、
関数型言語を学習するにあたって問題となるのは
関数型言語にはこれといった明確なデザインパターンが存在しないことでしょう。
[部分適用][link02] だとか [エラー処理のテクニック][link03] といったものはありますが、
[GoF的な][link04] 明確なパターンは存在しません。

この記事では **モノイド** と呼ばれる非常に一般的な「パターン」について説明します。
モノイドは厳密にはデザインパターンではありません。
どちらかというと、多数の様々な型を持った値を共通の方法で処理するための方法だと言えます。
実際、モノイドを理解した後になればあちこちで使われていることに気がつくようになるでしょう！

残念なことに「モノイド」という単語自体は少し紛らわしいものです。
元々は [数学][link05] 用語なのですが、プログラミングにこの概念を応用する場合には
数学の知識無しでも簡単に理解できるはずです。
それがこの記事の目的とするところであるわけですが。
実際、プログラミングの分野から見て名前をつけ直すことができるのであれば、
``ICombinable`` とでも呼ばれていたかもしれません。
これならそれほど怖くないでしょう。

最後に、「モノイド」は「モナド」と何か関連が有るのでは無いかと思うかもしれません。
その通り、両者には数学的な関連性があります。
しかしよく似た名前ではありますが、プログラミング用語的にはそれぞれ非常に異なるものです。

## えーとですね、、等式について

このサイトでは基本的に数学を必要としないようにしているのですが、
今回はその自分で決めたルールを破っていくつか等式を紹介します。

用意はいいですか？
まず1つ目です：

```fsharp
1 + 2 = 3
```

まだ大丈夫？
次はどうです？

```fsharp
1 + (2 + 3) = (1 + 2) + 3
```

最後にもう1つ...

```fsharp
1 + 0 = 1 かつ 0 + 1 = 1
```

以上！
これらの等式が理解できたのであればモノイドを理解するための数学的な知識は十分です。

## 数学者的に考える

> 「数学者は画家や詩人のようにパターンを作り出すものである。
> 数学者によるパターンが他よりも永続的なものだとすれば、
> それはパターンに数学者達の知識が詰め込まれているからだ。」G H Hardy

たいていの人は数学者といえば数字を扱ったり、複雑な数式や計算ばかりを
相手にしているものだと想像することでしょう。

しかし実際はそうではありません。
たとえば [典型的なレベルの高い][link06] [数学に関する議論][link07] を見てみると
奇妙な単語や文字、シンボルがたくさん現れるものの、数式はほとんど見かけません。

数学者の仕事の1つは、あるものに対するパターンを見つけ出そうとすることです。
一般的な数学の問題とは「これらに共通するものは何だ？」とか
「これらの概念をどうすれば一般化できるだろうか？」とかいうものです。

では先ほどの等式を数学者の視点で見てみることにしましょう。

### 1番目の等式の一般化

数学者は ``1 + 2 = 3`` という等式を目にすると以下のようなことを考えます：

* いくつかの要素がある（この場合は整数）
* それら2つを何らかの方法で連結している（この場合は加算）
* そしてそれらとは別に結果がある（2つとは別の整数）

そして数学者は別のものや演算子を使用してこのパターンを一般化出来ないだろうかと考えます。

ではまず整数を「何か」にするところから始めましょう。
整数を連結する別の方法があるでしょうか？
そしてそれは今回のパターンに一致するでしょうか？

まずかけ算から検討してみましょう。
パターンに一致しますか？

答えはYesです。
かけ算もやはり2つの整数を掛け合わせると別の整数値が結果になります。

割り算はどうでしょう？
パターンに一致しますか？
答えはNoです。
ほとんどの場合、割り算の結果は小数であり、整数にはなりません
（そのため整数値の割り算については無視します）。

``max`` 関数はどうでしょうか？
パターンに一致しますか？
この関数は2つの整数を受け取ってそれらのうちの1つを返すわけなので、答えはYesです。

``equals`` 関数はどうでしょうか？
この関数は2つの整数を受け取りますが、結果が整数ではなくブール値です。
したがって答えはNoです。

整数についてはこれで十分です！
他にどんなものが考えられるでしょうか？

浮動小数は整数によく似ていますが、整数と異なり浮動小数の割り算の結果は
別の浮動小数になるため、パターンに一致します。

ブール値はどうでしょうか？
ブール値はANDやORのような演算子で連結できます。
``aBool AND aBool`` の結果は別のブール値でしょうか？
そうです！
また ``OR`` でも同じです。

次は文字列です。
どうやって連結できるでしょうか？
1つの方法としては文字列連結することです。
これであれば別の文字列が結果になるためパターンに一致します。
ただし等式演算子など、結果がブール値になるものについては一致しません。

最後にリストを考えてみましょう。
文字列と同じく、リストはリスト同士を連結させることが出来、
別のリストが返されるわけなのでパターンに一致します。

こういった検討をすべてのオブジェクトと演算子の組み合わせに対して検討していくことができますが、
今はこれがどのように機能するのか見ていくことにします。

「演算子が同じ型の別のものを返すことがどうしてそれほど重要なのだろう？」
と疑問に思うかもしれません。
こういった演算子を使用すれば複数のオブジェクトを
演算子でつなぎ合わせることができるから、というのがその答えです。

たとえば``1 + 2``は別の整数を返すので、そこへさらに3を足すことができます。
そうすると``1 + 2 + 3``も整数を返すので、この結果に4を足すことができます。
別の言い方をすると、パターンに一致する整数の加算を使用すれば
``1 + 2 + 3 + 4``のように加算のシーケンスを記述できるというわけです。
整数の等式演算子はパターンに一致しないため、``1 = 2 = 3= 4``というようには記述できません。

もちろん、項目の連結のチェーンは任意個並べることができます。
つまりこのパターンを使用すれば、二項演算子を拡張して、
リストに対しても機能するような演算子にできるというわけです。

このように、「結果がそれぞれとは異なるもの」になるべきだという条件は、
数学的には **クロージャ** (closure)条件と呼ばれています。

### 2番目の等式の一般化

さて次の``1 + (2 + 3) = (1 + 2) + 3``という等式はどうでしょう？
何故これが重要なのでしょう？

1番目のパターンを検討した際、``1 + 2 + 3``というような演算子のチェーンを
作れるという説明をしました。
しかしそれは二項演算子に限定された話でした。
ではどういう順番で演算子を組み合わせたらよいのでしょう？
まず1と2を組み合わせてから、その結果と3を組み合わせる？
それとも2と3を組み合わせてから、1とその結果を組み合わせる？
これらは違う話なのでしょうか？

ここで2番目の等式が重要な意味をもってきます。
この等式からわかることは足し算であれば組み合わせる順序を気にする必要がないということです。
どの順序でも同じ結果が得られます。

つまり``1 + 2 + 3 + 4``のような式があるとして、
``((1+2) + 3) + 4``のように左側から計算しても、
``1 + (2 + (3+4))``のように右側から計算しても、
``(1+2) + (3+4)``のように2組の足し算を足してもよいわけです。

このパターンが既に検討してきた他の例に適用できるかどうかチェックしてみましょう。

まずは再び整数を組み合わせる場合を検討してみます。

再度かけ算から見てみましょう。
``1 * (2 * 3)`` と ``(1 * 2) * 3`` は同じですか？
そうです。
足し算と同じく、順序は重要ではありません。

引き算はどうでしょうか。
``1 - (2 - 3)`` と ``(1 - 2) - 3`` は同じ結果になりますか？
いいえ。
引き算の場合は順序が重要です。

割り算は？
``12 / (2 / 3)`` と ``(12 / 2) / 3`` は同じですか？
いいえ。
割り算も順序が重要です。

しかし ``max`` 関数はパターンに一致します。
``max( max(12,2), 3)`` と ``max(12, max(2,3))`` の結果は同じです。

文字列やリストはどうでしょう？
これらの連結機能はパターンに一致しますか？
どう思います？

ここで問題です。
果たして順序に依存するような文字列用の演算子を思いつけますか？

たとえば右側の文字列から左側の文字列をすべて取り除くような関数
removeAll はどうでしょう？
つまり ``removeAll("ab", "abc")`` が ``"c"`` になるような関数です。
``removeAll("abc", removeAll("abc", "abc"))`` の結果と
``removeAll(removeAll("abc", "abc"), "abc")`` の結果が異なるように、
``removeAll`` は順序に依存することがわかります。

このように「順序に依存しない」という条件は
数学的には **結合性** (associativity) 条件と呼ばれます。

重要な補足として、
以降で「連結の順序」という用語を使った場合には
対をなしている複数の連結処理、つまり1対を連結した後、
連結した結果と次の項目を連結するという処理の順序のことを指します。

ただし一連の項目の順序は変更されないものとします。
もしある特定の演算子に対して一連の項目の順序を変更してしまうと
得られる結果は全く違うものになります！
``1 - 2`` の結果は ``2 - 1`` とは違いますし、
``2 / 3`` の結果は ``3 / 2`` とは違います。

当然ながらたいていの場合には項目の順序は重要ではありません。
``1+2`` の結果は ``2+1`` と同じです。
このような演算子は **可換** (commutative)であるといいます。

### 3番目の等式


[link01]: http://fsharpforfunandprofit.com/posts/monoids-without-tears/ "Monoids without tears"
[link02]: http://fsharpforfunandprofit.com/posts/partial-application/ "Partial application"
[link03]: http://fsharpforfunandprofit.com/posts/recipe-part2/ "Railway oriented programming"
[link04]: http://en.wikipedia.org/wiki/Design_Patterns "Design Patterns"
[link05]: http://en.wikipedia.org/wiki/Monoid "Monoid"
[link06]: http://terrytao.wordpress.com/2013/07/27/an-improved-type-i-estimate/ "An improved Type I estimate"
[link07]: http://books.google.co.uk/books?id=VOCQUC_uiWgC&pg=PA102 "An Introduction to Category Theory"
