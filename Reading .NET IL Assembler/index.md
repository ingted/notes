# Reading ".NET IL Assembler"

## ilのコンパイル方法

    > call "%vs120comntools%vsvars32.bat"
    > ilasm.exe myasm.il

## 1章

* `.assembly extern` はアセンブリ参照を定義するもの。
  * 続くアセンブリ名にはファイル名を指定しない。
    * `mscorlib.dll` と指定してしまうと `mscorlib.dll.dll` だとか `mscorlib.dll.exe` が検索されてしまうので
      見つからずランタイムエラーになる。
  * `{ auto }` とするとバージョンを自動検出する。
    * ただし `1.0` と `1.1` には自動検出機能がないので注意。
* `.assembly <name>` で`Assembly`という名前のメタデータを定義。
* `.module <name>` で`Module`という名前のメタデータを定義。
* 値型と列挙型には疑似フラグ `value` と `enum` を指定出来る。
  * ただし `extends` が指定された場合はこれらのフラグは無視される。
* `TypeDef` ブロックは一度クローズしても、別の場所でオープンしなおすことが可能。
  * `amendment` (改正、修正)と呼ばれるテクニック。
  * `TypeDef` の改正時に指定されたフラグや`extends` `implement` 句は無視される。
    つまりこれらは最初の`TypeDef`定義時に指定すべき。
* アクセス修飾子
  * `public`は任意の場所にあるアセンブリからアクセス可能。
  * `assembly`は同じアセンブリ内からのみアクセス可能。
  * `family`はすべての子クラスからアクセス可能。
  * `famandassem`は同じアセンブリ内にあり、かつ子クラスからのみアクセス可能。
  * `famorassem`は同じアセンブリ内か、子クラスからのみアクセス可能。
  * `private`はクラス内からのみアクセス可能。
  * `privatescope`は同じモジュール内の任意の場所からアクセス可能。
    このフラグがデフォルト。
    `privatescope`は親/名前/シグネチャの3組によって識別される。
    つまり同じクラス、同じ名前、同じ型のプライベート項目を複数作成出来てしまうため非推奨。
* メソッド
  * インストラクション(命令：ILコードにコンパイルされる)
  * インストラクションをマーキングするラベル
  * ディレクティブ(メタデータ、ヘッダ設定、マネージ例外処理句などにコンパイルされる)
* `.locals`によって宣言されるローカル変数には必ず`init`を指定する
  * 変数がゼロ初期化される
  * 指定しない場合はエラー
    * 実行時に検証が失敗する
    * 検証が無効化されている場合は完全信頼モードでしか動作させられない
* ラベル
  * ラベルに続く***最初の命令***がマークされる
  * 個別の行に分ける必要は無し
* ILは厳密な***スタックベース***の言語
* ilasm 1.0/1.1 では前方方向しか参照できないので場合によって前方宣言する必要がある

## 2章

* ILにはローカル変数を読み取り/保存するための命令が4つまであらかじめ定義されている
  * `ldloc.0` .. `ldloc.3`, `stloc.0` .. `stloc.3`
* 標準形式の命令には4バイトの引数が続く
* 短縮形式の命令(`br.s` `brfalse.s` `brtrue.s`)には1バイトの引数が続く
  * つまり前方128バイト、後方127バイトまで
  * すべての命令に短縮形式があるので、255バイトの範囲を超えない限りは
    4つ以上の変数を渡しても大丈夫
* ILコンパイラによっては標準/短縮どちらの命令にすべきかを自動判断するものがあるが、
  .NET標準では書かれたとおりにしかコードが生成されない
* ilasmはildasmが生成したコードをコンパイルできないことがある
  * コードの最適化によってILコードが失われる場合があることが原因
* `ldc.i4.n` の `n` には `0` から `8` まで指定可能
  * `-1` をロードする場合は `ldc.i4.m1`
* `ldc.i4` の短縮形式 `ldc.i4.s` は同じく(`-128`から`127`までの)バイト値の範囲で機能する
* `try`ブロックはスタックが空の状態でなければ開始できない

## 3章

* ILの便利機能
  * エイリアス
  * コンパイル制御ディレクティブ
  * 現在のクラスおよび親を表す特別なキーワード
* エイリアス
  * `.typedef` キーワードで定義
  * クラス、メソッド、フィールド、カスタム属性に指定可能
  * メソッドのエイリアスを定義する場合、完全修飾名とシグネチャを指定する
    * `.typedef method`で始める
  * フィールドの場合も同じ
    * `.typedef field`で始める
  * カスタム属性のエイリアスについては16章まで保留
  * エイリアス名はモジュールの範囲で有効
    * 同一モジュール内での再定義は不可
  * エイリアスは字句的に使用される前の位置で定義する必要がある
  * モジュール内で一意であるべき
    * 別の2つの項目を同じエイリアスにすることはできない
    * 1つの項目に対して複数のエイリアスを定義することは可能
  * エイリアスはコンパイル後のアセンブリ内でも残る
    * `ildasm Simple3.exe`
    * `MANIFEST`内
* コンパイル制御ディレクティブ
  * `#include "<file name>"`
  * `#define <symbol name>`
  * `#define <symbol name> "Some text"`
  * `#undef`
  * `#ifdef`
  * `#ifndef`
  * `#else`
  * `#endif`
* 現在のクラスから相対的なオブジェクトを表すキーワード
  * `.this`
  * `.base`
  * `.nester`
    * ネストされたクラス内でのみ使用可能
    * ネスト元のクラスを表す(はず)

## 4章

* Microsoft Windows Portable Executable and Common Object File Format (PE/COFF)
* マネージ実行ファイルの構造
  * MS DOS ヘッダ (64 Bytes)
  * MS DOS スタブ (64 Bytes)
  * PE シグネチャ (4 Bytes)
  * COFF ヘッダ (20 Bytes)
  * PE ヘッダ (224 Bytes)
    * Data Directory Table
  * セクションヘッダ
* MS DOS ヘッダ/スタブ/PE シグネチャ
  * イメージファイルにのみ存在
  * 0x3Cの位置にPEシグネチャへのファイルポインタが格納されている
  * PEシグネチャはMS DOSスタブに続く4バイト
    * 必ずしも直後ではない
    * `P` `E` `null` `null`
* COFF ヘッダ
  * PEシグネチャの直後に格納されている
  * PE/COFFファイルの最も汎用的な性質が記述されている
  * COFFヘッダの定義は `Winnt.h`
  * `Characteristics` フィールド
    * 実行ファイルは `0x010E` (IMAGE_FILE_EXECUTABLE_IMAGE |
      IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED |
      IMAGE_FILE_32BIT_MACHINE)
    * DLLファイルは `0x210E` (IMAGE_FILE_EXECUTABLE_IMAGE |
      IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED |
      IMAGE_FILE_32BIT_MACHINE | IMAGE_FILE_DLL)
    * 64ビットバイナリの場合には `IMAGE_FILE_32BIT_MACHINE` が無いかも
    * CLR 4.0以降では 実行ファイルは `0x0022` DLLファイルは `0x2022`
* PE ヘッダ
  * `オプションヘッダ` ではあるが、オブジェクトファイルには含まれないというだけ
  * PEヘッダのサイズは不定
    * `SizeOfOptionalHeader` フィールドで指定
  * PEヘッダの定義は `Winnt.h`
* Data Directory Table
  * 32ビットの場合はオフセット96、64ビットの場合はオフセット112から開始
  * 0: エクスポートディレクトリテーブルアドレスおよびサイズ
  * 1: インポートテーブルアドレスおよびサイズ
  * 2: リソーステーブルアドレスおよびサイズ
  * 3: 例外テーブルアドレスおよびサイズ
  * 4: 認証テーブルアドレスおよびサイズ
  * 5: ベースリロケーションテーブルおよびサイズ
  * 6: デバッグデータアドレスおよびサイズ
  * 7: アーキテクチャデータアドレスおよびサイズ
  * 8: グローバルポインタ
  * 9: TLS(Thread Local Storage)テーブルアドレスおよびサイズ
  * 10: ロード設定テーブルアドレスおよびサイズ
  * 11: 境界インポートテーブルアドレスおよびサイズ
  * 12: インポートアドレステーブルアドレスおよびサイズ
  * 13: 遅延インポートデスクリプタアドレスおよびサイズ
  * 14: 共通言語ランタイムヘッダアドレスおよびサイズ
  * 15: 予約済み
* セクションヘッダ
  * 定義される位置は必ずPEヘッダの直後
  * COFFヘッダのNumberOfSectionsフィールドに個数が定義されている
  * 40バイトの構造体
  * `IMAGE_SECTION_HEADER` の `VirtualAddress` は実際にはセクションの始点のRVA
  * セクション名はイメージファイルではASCIIで8文字の制限があるが、オブジェクトファイルの場合はそれよりも長い名前にできる
* CLRヘッダ
  * .NET Framework SDKの`CorHdr.h`で定義されている
  * `COMIMAGE_FLAGS_ILONLY`フラグをセットするとWinXP以降のOSで実行した際に、
    スタートアップスタブのネイティブコードだけでなく、`.reloc`セクションも
    読み飛ばしてしまう。
    `.reloc`セクションには`.tls`セクションの始点と終点用の
   リロケーションや**データのデータ**(つまり他のデータへのポインタを含んだデータ)が含まれる。
   この問題があるので、32bit環境を対象にするのであれば代わりに
   `COMIMAGE_FLAGS_32BITREQUIRED`がセットされる。
  * `Flags`
    * `COMIMAGE_FLAGS_*`の値が入る
  * `EntryPointToken`にはエントリポイントとなる`MethodDef`または`File`のトークンが設定される
    * `File` トークンになるのはマルチモジュールアセンブリにおいて
      エントリポイントメソッドが別モジュールで定義されている場合のみ
    * エントリポイントメソッドになるのは以下のシグネチャのメソッドのみ
      * 返り値が`void`または4バイトの符号無し整数
      * 引数無し、または`string`か`string[]`型の引数を1つとる
    * DLLの場合には`EntryPointToken`は0
    * 混在コードDLLの場合は`COMIMAGE_FLAGS_NATIVE_ENTRYPOINT`フラグを設定した上で
      `EntryPointRVA`にネイティブエントリポイントメソッドのRVAを設定する。
  * `VTableFixups`
    * RVAとイメージファイルのvtable fixupテーブルのサイズを含むデータディレクトリ
    * マネージコードと非マネージコード間でデータをやりとりする際に参照される
    * マネージイメージのvtableはロード後にfixupが必要なので
      読み書きセクションに配置されるが、アンマネージイメージのvtableは
      読み取り専用セクションに配置される
  * `StrongNameSignature`
    * 厳密名ハッシュのRVAとサイズが含まれる
    * 厳密名のシグネチャはラウンドトリップには対応しない
      * 厳密名付きのモジュールをILディスアセンブラにかけた後、
        再度アセンブリにする場合には再び厳密名の署名が必要
    * `.text` セクションに配置される
  * `.reloc`
    * `Fixup`テーブルを含む
    * `.reloc`のRVAとサイズはPEヘッダのBase Relocationテーブルで定義
    * `Fixup`テーブルの各ブロックは4バイトにアラインされている
  * `.text`
    * マネージPEファイルの場合、メタデータテーブル、ILコード、
      Importテーブル、共通言語ランタイムヘッダ、CLR用の非マネージな
      スタートアップスタブが含まれる
    * ILアセンブラで生成した場合にはマネージリソースや
      厳密名シグネチャハッシュ、デバッグデータ、
      非マネージエクスポートスタブも含まれる
  * `.sdata`
    * データ定数、v-table、非マネージエクスポートテーブル、
      スレッドローカルストレージディレクトリが含まれる
    * スレッド固有のデータは`.tls`セクションに格納される
  * データ定数
    * 名前に反して読み書きセクションに配置される
    * 実際上書き可能
    * データのあり方というよりは使われ方に対する名前
  * v-table
    * 純粋なマネージモジュールにおいてはマネージメソッドを
      非マネージコードに公開するために使用される
    * 各エントリには4または8バイト長のスロットがある
    * `VTFixup`テーブルが`.text`セクションに格納されるのに対して、
      v-tableは`.sdata`セクションに格納される
  * 非マネージエクスポートテーブル
    * 非マネージイメージファイルの場合、非マネージエクスポートテーブルは
      `.edata`セクションに格納されるが、マネージイメージの場合はv-tableと
      同じく`.sdata`セクションに格納される
    * 5つのテーブルから成る
      * Export Directory
      * Export Address
      * Name Pointer
      * Ordinal
      * Export Name
  * スレッドローカルストレージ(TLS:Thread Local Storage)
    * TLSの説明は`.sdata`セクション内のTLSディレクトリにある
    * 64bitイメージの場合、最初の4つのフィールドが4バイト非負整数(`ULONG`)
      ではなく8バイト非負整数(`ULONGLONG`)
  * リソース
    * プラットフォーム固有の非マネージリソースと
      CLR固有のマネージリソースを格納できる
    * 非マネージリソース
      * `rsrc`セクションに格納される
      * 始点RVAとサイズはPEヘッダの`Resource`データディレクトリに記載
      * 種類、名前、言語によってインデックスされている
      * 上記の順でソート済み
      * ILアセンブラはモジュール毎に非マネージリソースファイル(`.res`)を
        1つだけ埋め込める
    * マネージリソース
      * `.text`セクションに格納される
      * 4バイト非負整数がリソースの長さを表し、
       それに続いてリソースそのものが格納される
* まとめ
  * イメージファイルの生成手順
    * 初期化
    * ソースコードの解析
    * イメージ生成
    * 完了処理

## 5章

* メタデータテーブルの構成
* メタデータとはデータを説明するためのデータ
* メタデータの役割はCOMにおける型ライブラリと似ているが、
  メタデータの方が情報量が多い
* 構造的にはメタデータは正規化されたリレーショナルデータベース
* メタデータには重複データが含まれない
  * 別のテーブルと同じデータを持つ必要がある場合にはそのテーブルを参照する
* クラス毎に整列されていないメソッドテーブルは
  **未最適化(unoptimized)**あるいは**未圧縮(uncompressed)**と呼ばれる
* ヒープ
  * 文字列ヒープ
    * 0終端のUTF-8エンコーディングされた文字列
    * ヒープの1バイト目は常に0(つまりヒープの最初の文字列は必ず空文字列)
    * ヒープの最後も0(つまりヒープの最後の文字列も0終端)
  * GUIDヒープ
    * 16バイトバイナリオブジェクト
    * 固定長なので長さおよび終端は不要
  * Blobヒープ
    * データ長に続いて(圧縮形式の)データが続く
    * 0x7F以下の場合はデータ長フィールドは1バイト
    * 0x7Fより大きく0x3FFF以下の場合は
      最大ビットがセットされた2バイトの非負整数
    * 0x3FFFを超える場合は最大ビット2つがセットされた4バイトの非負整数
    * 0x3FFFFFFF以上の圧縮データは扱えない
* 汎用メタデータヘッダ
  * 4バイトにアライン
  * 最初はマジックシグネチャ
    * `0x424A5342`または `BSJB`
      (1998年に開発を開始した当時の4人のイニシャル：Brian Harry, Susan Radke-Sproull, Jason Zander, Bill Evans)
  * バージョン文字列はCLRバージョンの文字列表現
    * `v4.0.30319`
    * Windows Runtimeは`WindowsRuntime`から始まるバージョン
      * `WindowsRuntime 1.2;Native code 1.2`
  * ストリームは6種類
    * `#Strings`
      * メタデータの名前を含む文字列ヒープ
    * `#Blob`
      * 規定値やシグネチャなど、内部的なメタデータバイナリを含むblobヒープ
    * `#GUID`
      * グローバルで一意な識別子であるGUIDヒープ
    * `#US`
      * ユーザー定義の文字列を含むblobヒープ
      * 文字列はUnicode(UTF-16)エンコーディング
        * 文字列内に0x007Fを超えるものが含まれるかどうかを示す1バイトが末尾に付く
      * ユーザー定義文字列はメタデータテーブルからは決して参照されないが、
        明示的に`ldstr`命令を使えばILコードから参照できる
      * blobなので実際にはUnicode文字列だけではなく
        バイナリオブジェクトも格納可能
    * `#~`
      * 圧縮済み(最適化済み)メタデータストリーム
    * `#-`
      * 非圧縮(未最適化)メタデータストリーム
      * ILAsmでは生成されない
  * `#~`と`#-`は相互排他
* RID
  * Record index
* Token
  * 4バイト非負整数
  * 最上位1バイトは0ベースのテーブルインデックス
  * トークンが割り当てられていない22個のテーブルは内部用
  * `mdtString (0x70000000)` のタイプのトークンは
    `#US`ストリームに格納されたユーザ定義の文字列用
  * ユーザー定義文字列トークンのRID(またはオフセット)コンポーネントは
    以下を満たす場合に限り妥当
    * 0より大きい
    * 4バイト境界から始まり、`#US` ストリーム内にすべて納まっていること
* Coded Token
  * Coded Tokenの種類は64から95まで、最大32グループまで定義可能
  * グループ内のテーブルに割り当てられた番号は**タグ(Tag)**と呼ばれる
  * タグは最下位ビットに置かれる
* バリデーション
  * PEVerify
    * MDValidator
    * ILVerifier

# 6章

* アセンブリとは
  * マネージアプリケーションのビルドブロック、配布単位
  * プライベートと共有の2種類に区別される
* プライベートアセンブリと共有アセンブリ
  * 構造的にも機能的にもこれらは同じもの
  * 名前や配布方法、ローダーによるバージョンチェック方法が異なる
* プライベートアセンブリ
  * 特定のアプリケーションの一部で、他のアプリケーションから利用されない想定
  * アプリと同じか、サブフォルダに配置される
  * 名前やバージョン規則はCLRによって強制されない(作者が自由に設定してよい)
* 共有アセンブリ
  * 特定のアプリケーションには属さず、様々なアプリから利用される想定
  * たとえば.NET Frameworkクラスライブラリ
  * 共有アセンブリの名前はグローバルに一意でなければいけない
  * 厳密名も必要
    * 公開鍵・秘密鍵ペアを使って生成
    * 名前の一意性を確保し、かつ偽装できないようにする
  * アセンブリのメタデータには公開鍵が埋め込まれて、厳密名シグネチャを検証できるようになっている
    * CLRのチェックにパスしたのであれば、使う側は秘密鍵を知らなくても発行者が正しかったと判断できる
  * グローバルアセンブリキャッシュ(GAC)に配置される
  * 共有アセンブリがアプリと同じディレクトリに配置されることもあるが、その場合は厳密名の有無によらず、共有アセンブリとはみなされない
* 論理的実行単位としてのアプリケーションドメイン
  * 各アプリは**アプリケーションドメイン**という単位で実行される
  * 各アプリケーションドメインには異なるセキュリティレベルを設定できる
  * あるアプリのコードは別のアプリにあるコードやリソースに直接アクセスできない
    (出来てしまうとセキュリティホールになる)
    * `mscorlib`だけは例外
    * `mscorlib`はAppDomainで共有される。プロセス間では共有されない。
  * あるアプリのエラーは別のプロセスに影響を与えない
  * 各アプリはコードの由来とロードするバージョンを制御できる。また、設定情報はアプリ単位で適用される。
* オブジェクトの区分
  * 束縛無し
    * ドメイン間を値でマーシャリングされる(つまりオブジェクトの複製が渡される)
  * AppDomain束縛
    * ドメイン間を参照でマーシャリングされる(プロキシ経由で操作される)
  * コンテキスト束縛
    * 同じドメインに属するコンテキスト間であれば参照でマーシャリングされる
* マニフェスト
  * アセンブリとモジュールに関する情報を持ったメタデータのこと
  * マニフェストに含まれる情報は以下の通り
    * 識別子(Identity)
      * 単純な名前
      * アセンブリのバージョン
      * カルチャ(ローカライズされたリソースを含まなければ省略可)
      * 公開鍵(厳密名を持つ場合のみ)
      * `Module` と `Assembly` メタデータテーブルで定義される
    * コンテンツ(Contents)
      * 型およびマネージリソース
      * `ExportedType` と `ManifestResource` メタデータテーブルで定義される
    * 依存関係(Dependencies)
      * アセンブリが参照する別のアセンブリ
      * マルチモジュールアセンブリの場合は別のモジュール
      * `AssemblyRef` `ModuleRef` `File` メタデータテーブルで定義される
    * 要求される権限(Requested permissions)
      * アセンブリ全体に適用される
      * 特定の型(クラス)やメソッドに限定することも可能
      * `DeclSecurity` メタデータテーブルで定義される
    * カスタム属性(Custom attributes)
      * 特定のマニフェストコンポーネントに適用される
      * コンパイラなどのツールによって利用される追加情報が付与される
      * CLRは一部のカスタム属性のみ認識する
      * `CustomAttribute` メタデータテーブルで定義される
* `Assembly` メタデータテーブル
  * `HahsAlgId`
    * CLR v1.0, 1.1, 2.0 でサポートされるのは`MD5(0x8003)`, `SHA1 (0x8004)`
    * CLR v4.0 でサポートされるのは上記と`SHA256(0x800C)`, `SHA384(0x800D)`, `SHA512(0x800E)`
  * `MajorVersion`
  * `MinorVersion`
  * `BuildNumber`
  * `RevisionNumber`
  * `Flags`
  * `PublicKey`
  * `Name`
  * `Locale`
* `AssemblyRef`
  * `MajorVersion`
  * `MinorVersion`
  * `BuildNumber`
  * `RevisionNumber`
  * `Flags`
  * `PublicKeyOrToken`
  * `Name`
  * `Locale`
  * `HashValue`
  * .NET 2.0 からは参照アセンブリの自動検出が可能

